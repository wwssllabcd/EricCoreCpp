#include "StdAfx.h"
#include ".\fat16.h"

#include "..\Utility\Utility.h"

Fat16::Fat16(void)
:type(0)
,jmpBoot(0)
,OEMName("");
,bpb_BytesPerSec(0)
,bpb_SecPerClu(0)
,bpb_RsvdSecCnt(0)
,bpb_NumFats(0)
,bpb_RootEntCnt(0)
,bpb_TotSec16(0)
,bpb_Media(0)
,bpb_FatSz16(0)
,bpb_SecPerTrk(0)
,bpb_NumHeads(0)
,bpb_HiddSec(0)
,bpb_TotSec32(0)
,bootSig(0)
,reserved1(0)
,drvNum(0)
{
}

Fat16::~Fat16(void)
{
}

void Fat16::loadNewFat16(ULONG totalSec, int sizeMB, int hiddenSec){

	int h(0),s(0);
	getHS(h,s,sizeMB);

	this->jmpBoot = 0x4D903CEB;
	this->OEMName = "MSWIN4.1";
	this->bpb_BytesPerSec = 512;
	this->bpb_SecPerClu  = _getSecPerCluster(sizeMB);
	this->bpb_RsvdSecCnt  = 1;
	this->bpb_NumFats  = 2;
	this->bpb_RootEntCnt  = 512;
	this->bpb_Media  = 0xF8;
	this->bpb_FatSz16  = getSecPerFat(totalSec);
	this->bpb_SecPerTrk  = s;
	this->bpb_NumHeads  = h;
	this->bpb_HiddSec = hiddenSec;

	if(totalSec <0x10000){
		this->bpb_TotSec16  = totalSec;
		this->bpb_TotSec32 = 0;
	}else{
		this->bpb_TotSec16  = 0;
		this->bpb_TotSec32 = totalSec;
	}

	this->drvNum  = 0x80;
	this->bootSig  = 0x29;

	//volID為4個BYTE ，並不是String
	//this->volID  = "MP FAT 16";
	this->volLab  = "NO NAME";
	this->filSysType  = "FAT16";
}

void Fat16::toAry(BYTE* array){
	unsigned char data[512] = {
		0xEB, 0x3C, 0x90, 0x4D, 0x53, 0x57, 0x49, 0x4E, 0x34, 0x2E, 0x31, 0x00, 0x02, 0x04, 0x01, 0x00, 
			0x02, 0x00, 0x02, 0x00, 0x00, 0xF8, 0xF4, 0x00, 0x20, 0x00, 0x10, 0x00, 0x20, 0x00, 0x00, 0x00, 
			0xE0, 0xD1, 0x03, 0x00, 0x80, 0x00, 0x29, 0xE5, 0x13, 0x6B, 0x33, 0x4E, 0x4F, 0x20, 0x4E, 0x41, 
			0x4D, 0x45, 0x20, 0x20, 0x20, 0x20, 0x46, 0x41, 0x54, 0x31, 0x36, 0x20, 0x20, 0x20, 0x33, 0xC9, 
			0x8E, 0xD1, 0xBC, 0xFC, 0x7B, 0x16, 0x07, 0xBD, 0x78, 0x00, 0xC5, 0x76, 0x00, 0x1E, 0x56, 0x16, 
			0x55, 0xBF, 0x22, 0x05, 0x89, 0x7E, 0x00, 0x89, 0x4E, 0x02, 0xB1, 0x0B, 0xFC, 0xF3, 0xA4, 0x06, 
			0x1F, 0xBD, 0x00, 0x7C, 0xC6, 0x45, 0xFE, 0x0F, 0x38, 0x4E, 0x24, 0x7D, 0x20, 0x8B, 0xC1, 0x99, 
			0xE8, 0x7E, 0x01, 0x83, 0xEB, 0x3A, 0x66, 0xA1, 0x1C, 0x7C, 0x66, 0x3B, 0x07, 0x8A, 0x57, 0xFC, 
			0x75, 0x06, 0x80, 0xCA, 0x02, 0x88, 0x56, 0x02, 0x80, 0xC3, 0x10, 0x73, 0xED, 0x33, 0xC9, 0xFE, 
			0x06, 0xD8, 0x7D, 0x8A, 0x46, 0x10, 0x98, 0xF7, 0x66, 0x16, 0x03, 0x46, 0x1C, 0x13, 0x56, 0x1E, 
			0x03, 0x46, 0x0E, 0x13, 0xD1, 0x8B, 0x76, 0x11, 0x60, 0x89, 0x46, 0xFC, 0x89, 0x56, 0xFE, 0xB8, 
			0x20, 0x00, 0xF7, 0xE6, 0x8B, 0x5E, 0x0B, 0x03, 0xC3, 0x48, 0xF7, 0xF3, 0x01, 0x46, 0xFC, 0x11, 
			0x4E, 0xFE, 0x61, 0xBF, 0x00, 0x07, 0xE8, 0x28, 0x01, 0x72, 0x3E, 0x38, 0x2D, 0x74, 0x17, 0x60, 
			0xB1, 0x0B, 0xBE, 0xD8, 0x7D, 0xF3, 0xA6, 0x61, 0x74, 0x3D, 0x4E, 0x74, 0x09, 0x83, 0xC7, 0x20, 
			0x3B, 0xFB, 0x72, 0xE7, 0xEB, 0xDD, 0xFE, 0x0E, 0xD8, 0x7D, 0x7B, 0xA7, 0xBE, 0x7F, 0x7D, 0xAC, 
			0x98, 0x03, 0xF0, 0xAC, 0x98, 0x40, 0x74, 0x0C, 0x48, 0x74, 0x13, 0xB4, 0x0E, 0xBB, 0x07, 0x00, 
			0xCD, 0x10, 0xEB, 0xEF, 0xBE, 0x82, 0x7D, 0xEB, 0xE6, 0xBE, 0x80, 0x7D, 0xEB, 0xE1, 0xCD, 0x16, 
			0x5E, 0x1F, 0x66, 0x8F, 0x04, 0xCD, 0x19, 0xBE, 0x81, 0x7D, 0x8B, 0x7D, 0x1A, 0x8D, 0x45, 0xFE, 
			0x8A, 0x4E, 0x0D, 0xF7, 0xE1, 0x03, 0x46, 0xFC, 0x13, 0x56, 0xFE, 0xB1, 0x04, 0xE8, 0xC2, 0x00, 
			0x72, 0xD7, 0xEA, 0x00, 0x02, 0x70, 0x00, 0x52, 0x50, 0x06, 0x53, 0x6A, 0x01, 0x6A, 0x10, 0x91, 
			0x8B, 0x46, 0x18, 0xA2, 0x26, 0x05, 0x96, 0x92, 0x33, 0xD2, 0xF7, 0xF6, 0x91, 0xF7, 0xF6, 0x42, 
			0x87, 0xCA, 0xF7, 0x76, 0x1A, 0x8A, 0xF2, 0x8A, 0xE8, 0xC0, 0xCC, 0x02, 0x0A, 0xCC, 0xB8, 0x01, 
			0x02, 0x80, 0x7E, 0x02, 0x0E, 0x75, 0x04, 0xB4, 0x42, 0x8B, 0xF4, 0x8A, 0x56, 0x24, 0xCD, 0x13, 
			0x61, 0x61, 0x72, 0x0A, 0x40, 0x75, 0x01, 0x42, 0x03, 0x5E, 0x0B, 0x49, 0x75, 0x77, 0xC3, 0x03, 
			0x18, 0x01, 0x27, 0x0D, 0x0A, 0x49, 0x6E, 0x76, 0x61, 0x6C, 0x69, 0x64, 0x20, 0x73, 0x79, 0x73, 
			0x74, 0x65, 0x6D, 0x20, 0x64, 0x69, 0x73, 0x6B, 0xFF, 0x0D, 0x0A, 0x44, 0x69, 0x73, 0x6B, 0x20, 
			0x49, 0x2F, 0x4F, 0x20, 0x65, 0x72, 0x72, 0x6F, 0x72, 0xFF, 0x0D, 0x0A, 0x52, 0x65, 0x70, 0x6C, 
			0x61, 0x63, 0x65, 0x20, 0x74, 0x68, 0x65, 0x20, 0x64, 0x69, 0x73, 0x6B, 0x2C, 0x20, 0x61, 0x6E, 
			0x64, 0x20, 0x74, 0x68, 0x65, 0x6E, 0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x20, 0x61, 0x6E, 0x79, 
			0x20, 0x6B, 0x65, 0x79, 0x0D, 0x0A, 0x00, 0x00, 0x49, 0x4F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
			0x53, 0x59, 0x53, 0x4D, 0x53, 0x44, 0x4F, 0x53, 0x20, 0x20, 0x20, 0x53, 0x59, 0x53, 0x7F, 0x01, 
			0x00, 0x41, 0xBB, 0x00, 0x07, 0x60, 0x66, 0x6A, 0x00, 0xE9, 0x3B, 0xFF, 0x00, 0x00, 0x55, 0xAA
	};

	memcpy(array,data, 512);
	Utility::toArray(this->jmpBoot, array, false);
	Utility::CStringToArray(array+3,this->OEMName,8);
	Utility::toArray(this->bpb_BytesPerSec, array+11, false);
	array[13] = this->bpb_SecPerClu;
	Utility::toArray(this->bpb_RsvdSecCnt, array+0x0E, false);
	array[0x10] = this->bpb_NumFats;
	Utility::toArray(this->bpb_RootEntCnt, array+0x11, false);
	Utility::toArray(this->bpb_TotSec16, array+0x13, false);
	array[0x15] = this->bpb_Media;
	Utility::toArray(this->bpb_FatSz16, array+0x16, false);
	Utility::toArray(this->bpb_SecPerTrk, array+0x18, false);
	Utility::toArray(this->bpb_NumHeads, array+0x1A, false);
	Utility::toArray(this->bpb_HiddSec, array+0x1C, false);

	Utility::toArray(this->bpb_TotSec32, array+0x20, false);
	array[0x24] = this->drvNum;
	array[0x26] = this->bootSig;

	//volID為4個BYTE ，並不是String
	//Utility::CStringToArray(array+0x27, this->volID, 4);
	Utility::CStringToArray(array+0x2B, this->volLab, 11);
	Utility::CStringToArray(array+0x36, this->filSysType, 8);
}

void Fat16::load(BYTE* bufFat){
	this->jmpBoot = *(ULONG*)(bufFat);
	//OEM Name
	this->OEMName = Utility::arrayToCString(bufFat+3,8);

	this->bpb_BytesPerSec = *(USHORT*)(bufFat+11);
	this->bpb_SecPerClu = *(bufFat+13);
	this->bpb_RsvdSecCnt = *(USHORT*)(bufFat+14);
	
	this->bpb_NumFats =  *(bufFat+16);
	this->bpb_RootEntCnt = *(USHORT*)(bufFat+17);
	this->bpb_TotSec16 = *(USHORT*)(bufFat+19);
	this->bpb_Media = *(bufFat+21);
	this->bpb_FatSz16 = *(USHORT*)(bufFat+22);
	this->bpb_SecPerTrk = *(USHORT*)(bufFat+24);
	this->bpb_NumHeads = *(USHORT*)(bufFat+26);
	this->bpb_HiddSec = *(ULONG*)(bufFat+28);
	this->bpb_TotSec32 = *(ULONG*)(bufFat+32);
		
	this->drvNum = *(bufFat+36);
	this->bootSig = *(bufFat+38);
	this->volID = Utility::arrayToCString(bufFat+39,4);
	this->volLab = Utility::arrayToCString(bufFat+43,11);
	this->filSysType = Utility::arrayToCString(bufFat+54,8);
}


//白皮書p13
ULONG Fat16::getDataSec(){
	ULONG DataSec=0;
	DataSec = getTotalSec() - this->bpb_RsvdSecCnt - (this->bpb_NumFats * getFatSize() )
		- getRootDirSectors();
	return DataSec;
}

//取得該Fat的TotalSec數(白皮書p14)
ULONG Fat16::getTotalSec(){
	return this->bpb_TotSec16;
}

//取得該Fat的TotalSec數(白皮書p14)
ULONG Fat16::getFatSize(){
	return this->bpb_FatSz16;
}

//白皮書p13
ULONG Fat16::getRootDirSectors(){
	ULONG rootDirSec = 0;
	rootDirSec = ((this->bpb_RootEntCnt * 32) + (this->bpb_BytesPerSec - 1)) / this->bpb_BytesPerSec;
	return rootDirSec;
}

ULONG Fat16::getTotalCluster(){
	return (getDataSec() / this->bpb_SecPerClu);
}


//p11-23，FAT 16
int Fat16::_getSecPerCluster(int sizeMB){
	int result(0);
	if( sizeMB<=32 ){
		result = 1;
	}else if(sizeMB<=64){
		result = 2;
	}else if(sizeMB<=128){
		result = 4;
	}else if(sizeMB<=256){
		result = 8;
	}else if(sizeMB<=512){
		result = 16;
	}else if(sizeMB<=1024){
		result = 32;
	}else if(sizeMB<=2048){
		result = 64;
	}else{
		throw exception( Utility::toString("FAT 16 can not support that the card size = %d", sizeMB) );
	}
	return result;
}


int Fat16::getSecPerFat(int TS){
	int rootDirSectors;
	int tempVal1,tempVal2;
	int fatSz;
	int DskSize = TS;

	rootDirSectors = ((this->bpb_RootEntCnt*32)+(this->bpb_BytesPerSec-1))/this->bpb_BytesPerSec;
	tempVal1 = DskSize - (this->bpb_RsvdSecCnt + rootDirSectors );
	tempVal2 = (256* this->bpb_SecPerClu ) + this->bpb_NumFats;
	fatSz = (tempVal1+ (tempVal2-1))/tempVal2;
	return LOWORD(fatSz);
}

//int Fat16::getDskSize(int sizeMB){
//	int result(0);
//	if( sizeMB<=16 ){
//		result = 32680;
//	}else if(sizeMB<=32){
//		result = 65360;
//	}else if(sizeMB<=64){
//		result = 131072;
//	}else if(sizeMB<=128){
//		result = 262144;
//	}else if(sizeMB<=256){
//		result = 524288;
//	}else if(sizeMB<=512){
//		result = 1048576;
//	}else if(sizeMB<=1024){
//		result = 2097512;
//	}else if(sizeMB<=2048){
//		result = 4194304;
//	}else{
//		throw exception( Utility::toString("FAT16 Error : Can`t get DskSize  = %d", sizeMB) );
//	}
//	return result;
//}

void Fat16::getHS( int& h, int& s, int sizeMB){
	if(sizeMB<=1024){
		h = 0x20;
		s = 0x3F;
	}else if(sizeMB<=2048){
		h = 0x40;
		s = 0x3F;
	}else{
		throw exception("FAT16 Error : Can`t get header and sector");
	}
}